-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.4).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module TIP.ParTIP
  ( happyError
  , myLexer
  , pStart
  , pListDecl
  , pDecl
  , pAssertion
  , pPar
  , pConstType
  , pInnerFunType
  , pFunType
  , pInnerFunDec
  , pFunDec
  , pBracketedFunDec
  , pDatatypeName
  , pInnerDatatype
  , pDatatype
  , pConstructor
  , pBinding
  , pLetDecl
  , pType
  , pExpr
  , pLit
  , pBinder
  , pCase
  , pPattern
  , pHead
  , pPolySymbol
  , pAttrSymbol
  , pAttr
  , pListLetDecl
  , pListCase
  , pListExpr
  , pListDatatype
  , pListConstructor
  , pListBinding
  , pListSymbol
  , pListType
  , pListFunDec
  , pListBracketedFunDec
  , pListAttr
  , pListDatatypeName
  , pSymbol
  ) where

import Prelude

import qualified TIP.AbsTIP
import TIP.LexTIP

}

%name pStart Start
%name pListDecl ListDecl
%name pDecl Decl
%name pAssertion Assertion
%name pPar Par
%name pConstType ConstType
%name pInnerFunType InnerFunType
%name pFunType FunType
%name pInnerFunDec InnerFunDec
%name pFunDec FunDec
%name pBracketedFunDec BracketedFunDec
%name pDatatypeName DatatypeName
%name pInnerDatatype InnerDatatype
%name pDatatype Datatype
%name pConstructor Constructor
%name pBinding Binding
%name pLetDecl LetDecl
%name pType Type
%name pExpr Expr
%name pLit Lit
%name pBinder Binder
%name pCase Case
%name pPattern Pattern
%name pHead Head
%name pPolySymbol PolySymbol
%name pAttrSymbol AttrSymbol
%name pAttr Attr
%name pListLetDecl ListLetDecl
%name pListCase ListCase
%name pListExpr ListExpr
%name pListDatatype ListDatatype
%name pListConstructor ListConstructor
%name pListBinding ListBinding
%name pListSymbol ListSymbol
%name pListType ListType
%name pListFunDec ListFunDec
%name pListBracketedFunDec ListBracketedFunDec
%name pListAttr ListAttr
%name pListDatatypeName ListDatatypeName
%name pSymbol Symbol
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('                 { PT _ (TS _ 1)             }
  ')'                 { PT _ (TS _ 2)             }
  '*'                 { PT _ (TS _ 3)             }
  '+'                 { PT _ (TS _ 4)             }
  '-'                 { PT _ (TS _ 5)             }
  '/'                 { PT _ (TS _ 6)             }
  '<'                 { PT _ (TS _ 7)             }
  '<='                { PT _ (TS _ 8)             }
  '='                 { PT _ (TS _ 9)             }
  '=>'                { PT _ (TS _ 10)            }
  '>'                 { PT _ (TS _ 11)            }
  '>='                { PT _ (TS _ 12)            }
  '@'                 { PT _ (TS _ 13)            }
  'Bool'              { PT _ (TS _ 14)            }
  'Int'               { PT _ (TS _ 15)            }
  'Real'              { PT _ (TS _ 16)            }
  '_'                 { PT _ (TS _ 17)            }
  'and'               { PT _ (TS _ 18)            }
  'assert'            { PT _ (TS _ 19)            }
  'declare-const'     { PT _ (TS _ 20)            }
  'declare-datatype'  { PT _ (TS _ 21)            }
  'declare-datatypes' { PT _ (TS _ 22)            }
  'declare-fun'       { PT _ (TS _ 23)            }
  'declare-sort'      { PT _ (TS _ 24)            }
  'define-fun'        { PT _ (TS _ 25)            }
  'define-fun-rec'    { PT _ (TS _ 26)            }
  'define-funs-rec'   { PT _ (TS _ 27)            }
  'distinct'          { PT _ (TS _ 28)            }
  'div'               { PT _ (TS _ 29)            }
  'exists'            { PT _ (TS _ 30)            }
  'false'             { PT _ (TS _ 31)            }
  'forall'            { PT _ (TS _ 32)            }
  'ite'               { PT _ (TS _ 33)            }
  'lambda'            { PT _ (TS _ 34)            }
  'let'               { PT _ (TS _ 35)            }
  'match'             { PT _ (TS _ 36)            }
  'mod'               { PT _ (TS _ 37)            }
  'not'               { PT _ (TS _ 38)            }
  'or'                { PT _ (TS _ 39)            }
  'par'               { PT _ (TS _ 40)            }
  'prove'             { PT _ (TS _ 41)            }
  'to_real'           { PT _ (TS _ 42)            }
  'true'              { PT _ (TS _ 43)            }
  L_integ             { PT _ (TI $$)              }
  L_UnquotedSymbol    { PT _ (T_UnquotedSymbol _) }
  L_QuotedSymbol      { PT _ (T_QuotedSymbol _)   }
  L_Keyword           { PT _ (T_Keyword $$)       }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

UnquotedSymbol :: { TIP.AbsTIP.UnquotedSymbol }
UnquotedSymbol  : L_UnquotedSymbol { TIP.AbsTIP.UnquotedSymbol (mkPosToken $1) }

QuotedSymbol :: { TIP.AbsTIP.QuotedSymbol }
QuotedSymbol  : L_QuotedSymbol { TIP.AbsTIP.QuotedSymbol (mkPosToken $1) }

Keyword :: { TIP.AbsTIP.Keyword }
Keyword  : L_Keyword { TIP.AbsTIP.Keyword $1 }

Start :: { TIP.AbsTIP.Start }
Start : ListDecl { TIP.AbsTIP.Start $1 }

ListDecl :: { [TIP.AbsTIP.Decl] }
ListDecl : {- empty -} { [] } | '(' Decl ')' ListDecl { (:) $2 $4 }

Decl :: { TIP.AbsTIP.Decl }
Decl
  : 'declare-datatype' AttrSymbol Datatype { TIP.AbsTIP.DeclareDatatype $2 $3 }
  | 'declare-datatypes' '(' ListDatatypeName ')' '(' ListDatatype ')' { TIP.AbsTIP.DeclareDatatypes $3 $6 }
  | 'declare-sort' AttrSymbol Integer { TIP.AbsTIP.DeclareSort $2 $3 }
  | 'declare-const' AttrSymbol ConstType { TIP.AbsTIP.DeclareConst $2 $3 }
  | 'declare-fun' AttrSymbol FunType { TIP.AbsTIP.DeclareFun $2 $3 }
  | 'define-fun' FunDec Expr { TIP.AbsTIP.DefineFun $2 $3 }
  | 'define-fun-rec' FunDec Expr { TIP.AbsTIP.DefineFunRec $2 $3 }
  | 'define-funs-rec' '(' ListBracketedFunDec ')' '(' ListExpr ')' { TIP.AbsTIP.DefineFunsRec $3 $6 }
  | Assertion ListAttr Expr { TIP.AbsTIP.Formula $1 $2 $3 }
  | Assertion ListAttr '(' Par Expr ')' { TIP.AbsTIP.FormulaPar $1 $2 $4 $5 }

Assertion :: { TIP.AbsTIP.Assertion }
Assertion
  : 'assert' { TIP.AbsTIP.Assert } | 'prove' { TIP.AbsTIP.Prove }

Par :: { TIP.AbsTIP.Par }
Par : 'par' '(' ListSymbol ')' { TIP.AbsTIP.Par $3 }

ConstType :: { TIP.AbsTIP.ConstType }
ConstType
  : Type { TIP.AbsTIP.ConstTypeMono $1 }
  | '(' Par Type ')' { TIP.AbsTIP.ConstTypePoly $2 $3 }

InnerFunType :: { TIP.AbsTIP.InnerFunType }
InnerFunType
  : '(' ListType ')' Type { TIP.AbsTIP.InnerFunType $2 $4 }

FunType :: { TIP.AbsTIP.FunType }
FunType
  : InnerFunType { TIP.AbsTIP.FunTypeMono $1 }
  | '(' Par '(' InnerFunType ')' ')' { TIP.AbsTIP.FunTypePoly $2 $4 }

InnerFunDec :: { TIP.AbsTIP.InnerFunDec }
InnerFunDec
  : '(' ListBinding ')' Type { TIP.AbsTIP.InnerFunDec $2 $4 }

FunDec :: { TIP.AbsTIP.FunDec }
FunDec
  : AttrSymbol InnerFunDec { TIP.AbsTIP.FunDecMono $1 $2 }
  | AttrSymbol '(' Par '(' InnerFunDec ')' ')' { TIP.AbsTIP.FunDecPoly $1 $3 $5 }

BracketedFunDec :: { TIP.AbsTIP.BracketedFunDec }
BracketedFunDec : '(' FunDec ')' { TIP.AbsTIP.BracketedFunDec $2 }

DatatypeName :: { TIP.AbsTIP.DatatypeName }
DatatypeName
  : '(' AttrSymbol Integer ')' { TIP.AbsTIP.DatatypeName $2 $3 }

InnerDatatype :: { TIP.AbsTIP.InnerDatatype }
InnerDatatype
  : '(' ListConstructor ')' { TIP.AbsTIP.InnerDatatype $2 }

Datatype :: { TIP.AbsTIP.Datatype }
Datatype
  : InnerDatatype { TIP.AbsTIP.DatatypeMono $1 }
  | '(' Par InnerDatatype ')' { TIP.AbsTIP.DatatypePoly $2 $3 }

Constructor :: { TIP.AbsTIP.Constructor }
Constructor
  : '(' AttrSymbol ListBinding ')' { TIP.AbsTIP.Constructor $2 $3 }

Binding :: { TIP.AbsTIP.Binding }
Binding : '(' Symbol Type ')' { TIP.AbsTIP.Binding $2 $3 }

LetDecl :: { TIP.AbsTIP.LetDecl }
LetDecl : '(' Symbol Expr ')' { TIP.AbsTIP.LetDecl $2 $3 }

Type :: { TIP.AbsTIP.Type }
Type
  : Symbol { TIP.AbsTIP.TyVar $1 }
  | '(' Symbol ListType ')' { TIP.AbsTIP.TyApp $2 $3 }
  | '(' '=>' ListType ')' { TIP.AbsTIP.ArrowTy $3 }
  | 'Int' { TIP.AbsTIP.IntTy }
  | 'Real' { TIP.AbsTIP.RealTy }
  | 'Bool' { TIP.AbsTIP.BoolTy }

Expr :: { TIP.AbsTIP.Expr }
Expr
  : PolySymbol { TIP.AbsTIP.Var $1 }
  | '(' Head ListExpr ')' { TIP.AbsTIP.App $2 $3 }
  | '(' 'match' Expr '(' ListCase ')' ')' { TIP.AbsTIP.Match $3 $5 }
  | '(' 'let' '(' ListLetDecl ')' Expr ')' { TIP.AbsTIP.Let $4 $6 }
  | '(' Binder '(' ListBinding ')' Expr ')' { TIP.AbsTIP.Binder $2 $4 $6 }
  | Lit { TIP.AbsTIP.Lit $1 }

Lit :: { TIP.AbsTIP.Lit }
Lit
  : Integer { TIP.AbsTIP.LitInt $1 }
  | '-' Integer { TIP.AbsTIP.LitNegInt $2 }
  | 'true' { TIP.AbsTIP.LitTrue }
  | 'false' { TIP.AbsTIP.LitFalse }

Binder :: { TIP.AbsTIP.Binder }
Binder
  : 'lambda' { TIP.AbsTIP.Lambda }
  | 'forall' { TIP.AbsTIP.Forall }
  | 'exists' { TIP.AbsTIP.Exists }

Case :: { TIP.AbsTIP.Case }
Case : '(' Pattern Expr ')' { TIP.AbsTIP.Case $2 $3 }

Pattern :: { TIP.AbsTIP.Pattern }
Pattern
  : '_' { TIP.AbsTIP.Default }
  | '(' Symbol ListSymbol ')' { TIP.AbsTIP.ConPat $2 $3 }
  | Symbol { TIP.AbsTIP.SimplePat $1 }
  | Lit { TIP.AbsTIP.LitPat $1 }

Head :: { TIP.AbsTIP.Head }
Head
  : PolySymbol { TIP.AbsTIP.Const $1 }
  | '@' { TIP.AbsTIP.At }
  | 'ite' { TIP.AbsTIP.IfThenElse }
  | 'and' { TIP.AbsTIP.And }
  | 'or' { TIP.AbsTIP.Or }
  | 'not' { TIP.AbsTIP.Not }
  | '=>' { TIP.AbsTIP.Implies }
  | '=' { TIP.AbsTIP.Equal }
  | 'distinct' { TIP.AbsTIP.Distinct }
  | '+' { TIP.AbsTIP.NumAdd }
  | '-' { TIP.AbsTIP.NumSub }
  | '*' { TIP.AbsTIP.NumMul }
  | '/' { TIP.AbsTIP.NumDiv }
  | 'div' { TIP.AbsTIP.IntDiv }
  | 'mod' { TIP.AbsTIP.IntMod }
  | '>' { TIP.AbsTIP.NumGt }
  | '>=' { TIP.AbsTIP.NumGe }
  | '<' { TIP.AbsTIP.NumLt }
  | '<=' { TIP.AbsTIP.NumLe }
  | 'to_real' { TIP.AbsTIP.NumWiden }

PolySymbol :: { TIP.AbsTIP.PolySymbol }
PolySymbol
  : Symbol { TIP.AbsTIP.NoAs $1 }
  | '(' '_' Symbol ListType ')' { TIP.AbsTIP.As $3 $4 }

AttrSymbol :: { TIP.AbsTIP.AttrSymbol }
AttrSymbol : Symbol ListAttr { TIP.AbsTIP.AttrSymbol $1 $2 }

Attr :: { TIP.AbsTIP.Attr }
Attr
  : Keyword { TIP.AbsTIP.NoValue $1 }
  | Keyword Symbol { TIP.AbsTIP.Value $1 $2 }

ListLetDecl :: { [TIP.AbsTIP.LetDecl] }
ListLetDecl
  : {- empty -} { [] } | LetDecl ListLetDecl { (:) $1 $2 }

ListCase :: { [TIP.AbsTIP.Case] }
ListCase : {- empty -} { [] } | Case ListCase { (:) $1 $2 }

ListExpr :: { [TIP.AbsTIP.Expr] }
ListExpr : {- empty -} { [] } | Expr ListExpr { (:) $1 $2 }

ListDatatype :: { [TIP.AbsTIP.Datatype] }
ListDatatype
  : {- empty -} { [] } | Datatype ListDatatype { (:) $1 $2 }

ListConstructor :: { [TIP.AbsTIP.Constructor] }
ListConstructor
  : {- empty -} { [] } | Constructor ListConstructor { (:) $1 $2 }

ListBinding :: { [TIP.AbsTIP.Binding] }
ListBinding
  : {- empty -} { [] } | Binding ListBinding { (:) $1 $2 }

ListSymbol :: { [TIP.AbsTIP.Symbol] }
ListSymbol : {- empty -} { [] } | Symbol ListSymbol { (:) $1 $2 }

ListType :: { [TIP.AbsTIP.Type] }
ListType : {- empty -} { [] } | Type ListType { (:) $1 $2 }

ListFunDec :: { [TIP.AbsTIP.FunDec] }
ListFunDec : {- empty -} { [] } | FunDec ListFunDec { (:) $1 $2 }

ListBracketedFunDec :: { [TIP.AbsTIP.BracketedFunDec] }
ListBracketedFunDec
  : {- empty -} { [] }
  | BracketedFunDec ListBracketedFunDec { (:) $1 $2 }

ListAttr :: { [TIP.AbsTIP.Attr] }
ListAttr : {- empty -} { [] } | Attr ListAttr { (:) $1 $2 }

ListDatatypeName :: { [TIP.AbsTIP.DatatypeName] }
ListDatatypeName
  : {- empty -} { [] } | DatatypeName ListDatatypeName { (:) $1 $2 }

Symbol :: { TIP.AbsTIP.Symbol }
Symbol
  : UnquotedSymbol { TIP.AbsTIP.Unquoted $1 }
  | QuotedSymbol { TIP.AbsTIP.Quoted $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

