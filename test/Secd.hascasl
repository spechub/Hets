library SecdMachine
version 0.1
%% authors: C.Maeder, T.Mossakowski, L.Schröder
%% Corresponding author: Christian Maeder, maeder@tzi.de
%% date: 17.09.02

%[from Basic/StructuredDatatypes get List]%

logic HasCASL

  spec Transitivity = 
  vars t,u : Type
  ops __subset__ : Pred(Pred(u) * Pred(u)); 
      transitive : Pred(Pred(t * t));
      tc : Pred(t * t) -> Pred(t * t)
  forall s, s': Pred(u); r, r': Pred(t * t)
  . s subset s' <=> Forall x: u . s x => s' x
  . transitive r <=> 
     forall x,y,z:t . r(x,y) /\ r(y,z) => r(x,z)
  . transitive(tc r)
  . r subset r' /\ transitive r' => (tc r) subset r'

  spec Reduction = Transitivity then
  types Value < Expr
  op reducesTo : Pred (Expr * Expr)
  forall x, y, z : Expr; v,w : Value 
   . not (reducesTo(x,x))                    
   . not (reducesTo(v,x))                    
   . transitive reducesTo                            
   . reducesTo(x,v) /\ reducesTo(x,w) => v = w                            

  spec Eval[Reduction] =  
  op eval: Expr ->? Value 
  forall e : Expr; v: Value 
   . eval e = v <=> reducesTo(e, v)
   vars t,u : Type

  spec Run =
  type State 
  op run : State ->? State

  spec Machine[Run] = 
  types Expr, Value
  ops    load: Expr -> State ;
         unload : State ->? Value

  spec Execution[Machine[Run]] = 
  op exec: Expr ->? Value 
  forall e: Expr 
  . exec e = unload(run(load e))

spec Step =
type State
op step : State ->? State

spec Iterate[Step] = Nat then
op iterate : Nat -> State ->? State
forall n : Nat; s : State
. iterate 0 s = s 
. iterate (n+1) s = iterate n(step s)

spec Count[Step] = Iterate[Step] then 
ops isFinal : Pred State;
    count : State ->? Nat;
    run : State ->? State 
forall n: Nat; s : State
. isFinal s => not (def (step s))
. count s = n <=> isFinal(iterate n s)
. run s = iterate (count s) s

  spec EvalByExecution = 
       Eval[Reduction] and Execution[Machine[Run]] then
  forall e : Expr
  . exec e = eval e

spec EvalByTimedExec = 
Eval[Reduction] and
Execution[Machine[Count[Step]]] hide iterate then
ops time: Expr -> Nat
forall e: Expr; t: Nat
. def (time e) <=> def  (eval e)
. def(eval e) => eval e = exec e
. def(count(load e)) => time e <=  count(load e)

view TimeRefine : EvalByExecution to EvalByTimedExec 

spec Term = FiniteSet then 
type Variable  %% unspecified  
  %[free type Term ::=    Var Variable | 
                        Lam Variable Term | 
                        App Term Term ]%
  ops fv : Term -> FiniteSet Variable ;
      isClosed: Pred Term  
  forall x:Variable; t, f, a: Term  
  . fv (Var x) = {x}              
  . fv (Lam x t) = (fv t) - {x}   
  . fv (App f a) = (fv f) + (fv a)  
  . isClosed t <=> (fv t) = {} 
  type ClosedTerm = { t : Term . isClosed t } 
  type Value = { a: ClosedTerm . exists x: Variable; b: Term . a = Lam x b }
  op App : ClosedTerm -> ClosedTerm -> ClosedTerm   %% redeclared
  op subst:ClosedTerm->Variable->Term->Term 
  ... %% Definition of substitution
then %implies  
  forall x: Variable; b: Term; a : ClosedTerm
  . isClosed(Lam x b) => isClosed(subst a x b)

  spec LeftReduction = TermAndTransitivityAndRecursion then 
  op leftRed: ClosedTerm ->? ClosedTerm
  program leftRed (App (App f a) c) = App (leftRed (App f a))c;
     leftRed(App (Lam x b)(App f a)) = 
     App (Lam x b) (leftRed (App f a)); 
     leftRed(App (Lam x b)(Lam y t)) = 
          (subst (Lam y t) x b) as ClosedTerm
  op leftRel,reducesTo: Pred (ClosedTerm * ClosedTerm)
  forall a,b : ClosedTerm
  . leftRel(a, b) <=> leftRed a = b
  . reducesTo = tc leftRel

view TermReduction : Reduction to LeftReduction =
  sort Expr |-> ClosedTerm

spec Closure = Term then 
%[free types Env ::= Empty | Add Variable Clos Env ;
           TermEnv ::= Clos Term Env
]%
ops lookup : Env -> Variable ->? Clos;
    remove: Env -> Variable ->? Env;
    real : TermEnv ->? ClosedTerm
forall e : Env; x: Variable; c: Clos; t: Term
. real (Clos t Empty) = t as ClosedTerm
. real (Clos t (Add x c e)) = 
        real (Clos (subst (real c) x t)(remove x e))
type Clos = {c: TermEnv. def(real c)}

spec Dump = Closure and {List with [], __::__} and Recursion then 
free type ExtTerm ::= Aps | type Term 
type Control := List ExtTerm    %% synonyms                  
type Stack := List Clos              
type Dump := List (Stack * Env * Control)     
op step : Dump ->? Dump
program step((s, e, (Var x) :: c) :: d) = ((lookup e x) :: s, e, c) :: d;
step((s, e, (Lam x b) :: c) :: d) =  
     ((Clos(Lam x b) e) :: s, e, c) :: d; 
step((s, e, (App f a):: c) :: d) = (s, e, a :: f :: Aps :: c) :: d; %(apply)%
step(((Clos(Lam x b) e_0) :: v :: s, e, Aps :: c) :: d) =
    ([], Add x v e_0, b :: []) :: (s, e, c) :: d;             %(call)%
step((v :: [], e_0, []) :: (s, e, c) :: d) = (v :: s, e, c) :: d %(return)%

spec Repeat[Step] = Recursion and Nat then 
ops repeat : (State -> Bool) -> State ->? State
    count : (State -> Bool) -> State ->? Nat
program repeat p s = if p s then s else repeat p(step s); 
   count p s = if p s then 0 else 1 + count p(step s) 

  view DumpStep : Step to Dump =
      sort State |-> Dump

spec SecdMachine = Repeat[view DumpStep] then 
ops load : ClosedTerm -> Dump;
    unload : Dump ->? Value; 
    isFinal : Dump -> Bool;
    run : Dump ->? Dump
program load a = ([], Empty, a :: []) :: [] ;
 unload ((v :: [], Empty, []) :: []) = (real v) as Value;
 isFinal d = case d of (v :: [], Empty, []) :: [] -> True | 
               __ -> False;
 run d = repeat isFinal d

view Secd : Machine[Run] to SecdMachine =
     sorts State |-> Dump, Expr |-> ClosedTerm

spec Time = Eval[view TermReduction] then 
op time : ClosedTerm ->? Nat 
forall x: Variable; a, b, f : ClosedTerm; v: Value
. time v = 1
. time (App f a) = 
   let Lam x b = eval f ; v = eval a in 
        (time a) + (time f) + (time((subst v x b)as ClosedTerm)) +1

spec TermEvalBySecdExec = 
     Time and Execution[view Secd]

view Implementation : EvalByTimedExec to TermEvalBySecdExec =
      sorts State |-> Dump, Expr |-> ClosedTerm
