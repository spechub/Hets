\documentclass[11pt,a4paper]{article}

\usepackage{german}
\usepackage{amssymb}
\usepackage{epsfig}
\usepackage{graphics}
\usepackage{graphicx}
\usepackage{moreverb}
\usepackage[latin1]{inputenc}   % Unterstuetzen von deutschen Umlauten

% gieza bigger page
\setlength{\textwidth}{16cm}
\setlength{\topmargin}{-1cm}
\setlength{\evensidemargin}{0cm}
\setlength{\oddsidemargin}{0cm}
\setlength{\textheight}{24cm}

% skip between paragraphs
\setlength{\parskip}{1ex}
% ... and no indentation at start of a new paragraph
\setlength{\parindent}{0ex}

\pagestyle{plain}
\thispagestyle{plain}
\begin{document}

\title{A roadmap for the implementation of an OWL-DL logic}
\author{Klaus L"uttich, Heng Jiang}
\maketitle

%\tableofcontents

\section{General Ideas}

\subsection{parsing and analysis}
parsing and first analysis are done in JAVA
   \subsubsection{Used libraries}
   all used Java-libraries are from the tools Pellet 1.1.0:
   \begin{itemize}
   \item pellet-1.1.0/lib/aterm-java-1.6.jar
   \item pellet-1.1.0/lib/log4j-1.2.7.jar
   \item pellet-1.1.0/lib/pellet.jar
   \item pellet-1.1.0/lib/rdfapi.jar  
   \item pellet-1.1.0/lib/econn-owlapi/abstractparser.jar
   \item pellet-1.1.0/lib/econn-owlapi/impl.jar
   \item pellet-1.1.0/lib/econn-owlapi/io.jar  
   \item pellet-1.1.0/lib/econn-owlapi/rdfparser.jar
   \item pellet-1.1.0/lib/econn-owlapi/validation.jar
   \item pellet-1.1.0/lib/junit-3.8.1/junit.jar
   \end{itemize}
In it nothing will be changed, the implementation however some new classes produced, by which the old classes are replaced:
   \begin{itemize}
      \item OWL2ATermLoader instead PelletLoader;
          \item OWL2ATermVisitor instead PelletVisitor;
      \item RenderingVisitor2 instead RenderingVisitor
   \end{itemize}

\subsubsection{Class interpreting}
\textbf{\emph{OWL2ATermLoader} }and \textbf{\emph{OWL2ATermVisitor}} are the classes as interfaces, with which main class (\textbf{\emph{OWL2ATerm}}) with the Visitor and Render (concrete output classes: \textbf{\emph{ATermRender2}}) can be connected. With OWL2ATermLoader we can still administered the KnowledgeBasis, which gets the original PelletLoader of OWL Parser.\\
   
\textbf{\emph{ATermRender2}} and \textbf{\emph{RenderingVisitor2}} are the major output classes in this implementation.\\

All class-, property and individual data structures are developed in \textbf{\emph{ATermRender2}}.  Since such data struktures with many parameters and is very complicated (for example, Class has 5 parameters, whereby Description is still another data strukture, which must be unwrapped and represented as a list), the result of the OWL Parsers is not directly to be used, but must be first analyzed here, at the end output a ATerm, which is based structurally on the abstract syntax of Haskell.\\

RenderingVisitor2 is here an assistance class of the expenditures to design only the simple ClassID and Restrictions in addition class-, property- and individual- axioms.  Because restriction and axiom need only ID (not concrete data structure) as parameters, those are converted to need URI to it.  The different axioms are dependent on the KnowledgeBasis, which in this class however not at all produced or changed, but already one specifies in OWL2ATerm.\\

\textbf{\emph{OWL2ATerm}} is the main class, in which the OWLParser is called.  All output messages of the Parser are collected by a assistance class \textbf{\emph{OWLATReporter}} and stored into a MessageList.  The messages are divided in 3 parts:
        \begin{itemize}
                \item Level: OWL-\{Lite, DL, Full\}.
                \item Type of Message.
                \item content of message.
        \end{itemize} 
Afterwards Parser errors and warnings behind the messages are inserted also in the message list. \\
The method "'owlParserOutput"' builds all necessary information up from the Parser, and spends at the end an entire ATerm formula (OWLParserOutput(validation, messages, name spaces, ontology)):
        \begin{itemize}
                \item validation: OWL-\{Lite, DL, Full\}.
                \item messages: all messages from OWL parser incl. parser errors and warnings.
                \item namespaces: here namespaces are stored also as some of the output. Thus all URI can be developed late in Haskell with suitable namespaces.
                \item ontology: main part of the result ATerm, therein all classes, properties, individuals and axioms are outputs.
        \end{itemize} 
   With the above implementation all output ATerm is developed so near by the abstract syntax by OWL\_DL, which is builded in Haskell, that later very simply to the Haskell abstract syntax converts becomes (see AS.hs and ATerm module of HETS)\\

   the JAVA output is an unshared ATerm-file.\\

   @Dominik: try to contact the person maintaining the JAVA-ATerm
   library and try to get a fix for the textual shared format writing
   bug. 

\subsection{Representation}
The ATerm represents the abstract syntax after reading all
   imports. It has a classification in OWL-{Lite,DL,Full} and the used
   XML-namespaces are saved. Mutual recursive (circular) imports are
   solved by integration of all information into one abstract syntax.

\subsection{Circular imports} 

   Circular imports need to be detected and yield a
   warning.\\
   
The integrated abstract syntax will be devided into different
   theories if there are no circular imports. It maybe easier to leave
   them in one therory first. Maybe later a division can be added.
   We derive a development graph from the import structure of the 
   OWL-DL-files if there are no circular imports.

\section{Static analysis of abstract syntax in Haskell within Hets}
   \begin{enumerate}
   \item splitting of OWL-DL-IDs into namespace and local-name part
       with a disambiguation of IDs which have the same local-name
       part.

   \item detection of circular imports and construction of import
       structure as graph, where the nodes are labeled with the same
       labels as in (3).

   \item if there are no circular imports, divide the axioms into lists
       according to there originating files. These lists must be
       labeled with names derived from the ontology name/location.
       Otherwise all axioms stay in one list.

   \item each list of axioms is now analysed. This process yields a
       theory (signature and sentences) foreach list of axioms labeled
       with each name. According to the import structure graph these
       theories form now a development graph. All signature morphisms
       are just inclusions where the source sign is a subset of the
       target sign.
   \end{enumerate}

\section{Detailed Advices}

\subsection{Static Analysis of OWL DL Abstract Syntax}

(all numbers refer to the overview in the previous section)

\begin{itemize}
\item 
  splitting of (1) is done best during the conversion of the ATerm
  into the abstract syntax. For the *ID types in OWL\_DL.AS the best
  data type is QName from Text.XML.HXT.DOM.XmlTreeTypes where also
  some useful functions on QName are defined.
  
\item Disambiguation of (1) must be done in a second step, which must
  traverse the whole AS-tree. The traversal function (in its own
  class) needs a map as parameter which stores the mapping between
  original and disambiguated name. A disambiguated name can be formed
  either by adding a unique number as suffix or by adding the
  namePrefix string followed by an underscore as prefix.  In this step
  all QName entries can be updated with the namespaceURI part.  The
  map will be saved later in a datastructure that is global to the
  development graph.

\end{itemize}
\end{document}
